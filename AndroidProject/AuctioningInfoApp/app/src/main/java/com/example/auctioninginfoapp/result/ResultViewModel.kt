package com.example.auctioninginfoapp.result

import android.content.Context
import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.auctioninginfoapp.database.DatabaseModule
import com.example.auctioninginfoapp.model.FreshData
import com.example.auctioninginfoapp.model.FreshWrapper
import com.example.auctioninginfoapp.model.Fruits
import com.example.auctioninginfoapp.model.SaveItem
import com.example.auctioninginfoapp.network.NetworkModule
import com.example.freshauctionapp.util.SingleLiveEvent
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import kotlinx.coroutines.CoroutineExceptionHandler
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import ru.gildor.coroutines.okhttp.await

/** 검색한 농산물 경락가격정보를 관리하는 ResultViewModel 선언
 *  - 농산물 경락가격정보 요청하고, 그 결과를 SaveItem, Fresh 테이블에 저장  */
class ResultViewModel() : ViewModel() {
    /** JSON 라이브러리 moshi 플러그인 참조 */
    val moshi by lazy {
        Moshi.Builder().add(KotlinJsonAdapterFactory()).build()
    }

    /** notificationMsg LiveData 선언(SingleLiveEvent<String>)
     *  - 코루틴에서 발생한 Exception을 처리하기 위한 CoroutineExceptionHandler에서 출력한
     *    exception.message를 SingleLiveEvent<String> 형태로 저장할 notificationMsg 선언
     *
     *  - public final class SingleLiveEvent<T> : MutableLiveData<T>
     * */
    val notificationMsg: SingleLiveEvent<String> = SingleLiveEvent()

    /** resultList LiveData 선언(SingleLiveEvent<List<FreshData>>)
     *  - 검색 결과를 SingleLiveEvent<List<FreshData>> 형태로 저장할 resultList 선언
     * */
    private val resultList: SingleLiveEvent<List<FreshData>> = SingleLiveEvent()

    /** resultList 속성의 getter 함수(resultList를 LiveData<List<FreshData>> 형태로 반환  */
    fun getResultList(): LiveData<List<FreshData>> = resultList

    /** 검색 결과를 SaveItem 테이블과 Fresh 테이블에 저장 */
    fun saveResult(context: Context, saveName: String) {
        viewModelScope.launch(Dispatchers.IO) {
            /** SaveItem 테이블에 경락가격정보 목록(id, saveTitle) 저장
                - 먼저 저장 항목리스트(SaveItem)를 만들어서 autoGenerated된 ID값을 받은다음,
               - freshdata(각각의 개별 데이터)를 리스트 ID값과 함께 저장.
             */
            DatabaseModule.getDatabase(context).freshDao().insertSave(
                SaveItem(id = null, saveTitle = saveName)//saveName: "2023-01-01 사과 검색결과"
            ).run {
                /** Fresh 테이블에 경락가격정보 저장 */
                resultList.value?.let { datas ->
                    datas.forEach { it.saveId = this }

                    Log.i("SAVERESULT", "datas: $datas")
                    /** SAVERESULT
                     * FreshData(id=null, saveId=1, mname=사과, ...., tradeAmt=1)
                     * FreshData(id=null, saveId=1, mname=사과, ...., tradeAmt=1)
                       :
                     ** [Fresh] table에 저장
                       id    saveId    mname ............ tradeAmt
                       1     1         사과               1
                       2     1         사과               1
                             :
                     */
                    DatabaseModule.getDatabase(context).freshDao().insertFresh(datas)
                }
            }
        }
    }//end of saveResult

    /** 코루틴 실행중 발생한 Exception을 처리하기 위한 CoroutineExceptionHandler 설정 
     *  - errorHandler는 CoroutineExceptionHandler를 구현하며,
     *    Exception이 발생하면 선언한 람다식을 실행
     */
    private val errorHandler = CoroutineExceptionHandler { _, exception ->
        exception.message?.let { Log.e("error", it) }
        notificationMsg.postValue(exception.message)
    }

    /** Request 객체 생성 함수 */
    fun loadDataFromURL(
        selectDate: String,
        selectFruit: String,
        resultAmount: String
    ) {
        /** Request(요청) 객체 생성 */
        val httpUrl = NetworkModule.makeHttprequest(
            /** 품종코드, 검색일자, 검색수량을 인자로 HttpUrl 객체 생성 */
            NetworkModule.makeHttpUrl(
                scode = Fruits.valueOf(selectFruit).scode,
                date = selectDate,
                amount = resultAmount
            )
        )
        Log.i("HTTP", httpUrl.toString())
        /** Request{method=GET, url=http://211.237.50.150:7080/openapi/YOUR-API-KEY/json/
         *               Grid_20160624000000000348_1/1/20?AUCNG_DE=20230526&SPCIES_CD=060103} */

        /** Coroutine을 이용하여 IO 스레드에서 농산물 공공DB포털에 경락가격정보 요청  */
        viewModelScope.launch(Dispatchers.IO + errorHandler) {
            /**  OkHTTPClient를 이용하여 네트워크 통신(경락가격 정보를 서버에 요청)
                - OkHTTPClient.newCall()의 인자로 Request 객체(request)를 전달하여
                  응답(response) 객체 생성
                - IO 스레드에서 네트워크 통신을 한 다음에(await로 IO 스레드가 완료될때까지 기다림)
             */
            val response = NetworkModule.clinent.newCall(httpUrl).await()
            Log.d("RESPONSE", "$response")

            /** 응답 결과(response, Json 형식)를  List<FreshData> 형식의 객체로 변환 */
            val freshData =
                response.body?.string()?.let { mapppingStringToFresh(it) } ?: emptyList()

            if(freshData.isEmpty()){
                notificationMsg.postValue("데이터가 존재하지 않습니다.")
            }

            /** resultList에 freshData를 저장(SingleLiveEvent<List<FreshData>>) */
            resultList.postValue(freshData)
        }
    }//end of loadDataFromURL

    /** Moshi(JSON 라이브러리)를 이용하여 응답 결과인 JSON 형식의 데이터를 파싱하여
     *  List<FreshData> 형식으로 반환하는 함수 */
    private fun mapppingStringToFresh(jsonBody: String): List<FreshData> {
        /** JSON 형식의 데이터를 FreshWrapper 클래스 형식으로 파싱해주는 DTO(어댑터) 생성 */
        val freshStringToJsonAdapter = moshi.adapter(FreshWrapper::class.java)

        /** FreshWrapper 클래스 형식으로 파싱 */
        val freshResponse = freshStringToJsonAdapter.fromJson(jsonBody)
        Log.i("LIST", "$freshResponse")

        if (freshResponse?.errorCode != null) {
            /** 에러메세지를 명시적으로 알려주기위해 에러를 발생시키고,
             *  이곳에서 발생한 에러는 notificationMsg를 통해 받음 */
            throw Error(freshResponse.errorCode.message)
        }
        /** data class ResultMeta(
         *   :
         *  @Json(name = "row")
         *  var row: List<FreshData> 반환
         *  */
        return freshResponse?.list?.row ?: emptyList()
    }//end of mapppingStringToFresh
}
